<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Interchange</title>
        <link>http://sintrastes.github.io/blog</link>
        <description><![CDATA[Nathan's Development blog.]]></description>
        <atom:link href="http://sintrastes.github.io/blog/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Fri, 17 Dec 2021 00:00:00 UT</lastBuildDate>
        <item>
    <title>Being explicit about implicit conversions</title>
    <link>http://sintrastes.github.io/blog/posts/2021-12-17-being_explicit_about_implicit_conversions.html</link>
    <description><![CDATA[<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Interchange - Being explicit about implicit conversions</title>
        <link rel="stylesheet" href="/css/light-theme.css" />
        <link rel="stylesheet" href="/css/light-syntax.css" />
        <link rel="stylesheet" href="/css/slider.css" />
        <link href="https://sintrastes.github.io/blog/atom.xml" type="application/atom+xml" rel="alternate" title="Sitewide Atom feed" />
        <link href="https://sintrastes.github.io/blog/rss.xml" type="application/rss+xml" rel="alternate" title="Sitewide Rss feed" />

        <script>
            function toggleTheme() {
                // Obtains an array of all <link> elements.
                // Select your element using indexing.
                var theme = document.getElementsByTagName('link')[0];
                var syntaxTheme = document.getElementsByTagName('link')[1];
      
                // Change the value of href attribute 
                // to change the css sheet.
                if (theme.getAttribute('href').includes('light-theme.css')) {
                    theme.setAttribute('href', 'https://sintrastes.github.io/blog/css/dark-theme.css');
                    syntaxTheme.setAttribute('href', 'https://sintrastes.github.io/blog/css/dark-syntax.css');
                } else {
                    theme.setAttribute('href', 'https://sintrastes.github.io/blog/css/light-theme.css');
                    syntaxTheme.setAttribute('href', 'https://sintrastes.github.io/blog/css/light-syntax.css');
                }
            }
            
            
        </script>
    </head>
    <body> 
        <div id="header-wrapper">
	<div id="header">
		<div id="blog-title">
          <div horizontal layout>
            <a href="#">
              <h2>Interchange</h2>
            </a>
            <div id="subheading">
              <h3> : A blog about category theory, logic, and programming.</h3>
            </div>
          </div>
		</div>
		<div id="menu">
		  <ul>
		    <li><a href="https://sintrastes.github.io/" accesskey="1" title="">Homepage</a></li>
			<li class="active"><a href="#" accesskey="4" title="">Blog</a></li>
			<li>
			  <label class="switch">
			    <img height="16" src="http://sintrastes.github.io/blog/images/contrast.png"></img>
			    <div>
				  <input type="checkbox" onclick="toggleTheme()"/>
              	  <span class="slider round"></span>
                </div>
		      </label>
			</li>
		  </ul>
		</div>
	</div>	
</div>
<div id="wrapper">
  <div>
    <article>
        <section class="header">
          <div class="title">
            <h2>Being explicit about implicit conversions</h2>
            <p>
              Posted on December 17, 2021
              
                by Nathan Bedell
              
            </p>
          </div>
        </section>
        <section class="container" id="body">
            <p>A lot of the time, I think developers develop cognitive biases against certain features after spending a lot of time being frustrated by a particular implementation of that feature. For instance, checked exceptions have left a bad taste in many a Java developer’s mouth, and many will go on to say simply that “checked exceptions are bad”, whereas if you dig deeper, people will often point out that the real issue is the false sense of security that such checked exceptions lead to, due to the distinction between checked and unchecked exceptions, or generally other issues with this distinction. For instance, a <code>NullPointerException</code> in Java is unchecked (i.e. doesn’t have to be declared in the <code>throws</code> block of a function signature) – which was arguably <a href="https://en.wikipedia.org/wiki/Null_pointer#History">a mistake</a>. And such hiccups in the design have led designers of newer languages like Kotlin to leave out the feature entirely, even though, I’d argue, in a language that often emphasizes safety, checked exceptions would be a great feature to have in Kotlin!</p>
<p>In the Kotlin standard library, there is <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/first.html">a method</a> <code>List&lt;A&gt;.first(): A</code> that returns the first element of a list. Well, that is, so long as the list actually has a first element. On an empty list, <code>first</code> will throw a <code>NoSuchElementException</code>. It says as much in the documentation. Yet there is nothing in the language preventing me from using this function without first checking that the list is non-empty, like there would be with checked exceptions. Of course, one could use data types like <code>Maybe</code> and <code>Either</code> from the typed functional programming world, but I’d argue that those are not always as ergonomic as exceptions and null values – especially in a language where Java interop is important. So why not have the best of both worlds? Kotlin already explicitly handles <code>NullPointerExceptions</code> (a unchecked exception in Java) with it’s null safety mechanisms – why not <code>NoSuchElementException</code> as well? Just because Java isn’t safe enough with it’s checked exceptions doesn’t mean we have to toss it entirely. We should go the other way and make it as safe as it should have been in the first place.</p>
<p>There are other issues with checked exceptions one could bring up, and I may address those in another blog post, but for now I’d like to address a similar bias against <em>implicit conversions</em>.</p>
<h2 id="strength-is-in-the-eye-of-the-beholder">Strength is in the eye of the beholder</h2>
<p>The discussion of implicit conversions is related to that of “strong” v.s. “weak” typing. This can be confusing, because arguably, the term “strongly typed” has at least two separate meanings:</p>
<ol type="1">
<li>A language is (more or less) strongly typed to the degree in which it permits implicit conversions.</li>
<li>Code is more or less strongly typed to the degree in which the developer makes use of types to capture invariants of their code to ensure correctness. (This could also be said of a langauge – meaning the degree to which the language allows or facilitates such a discipline.)</li>
</ol>
<p>For instance, Haskell might be said to be more strongly typed than Java, because it has features like sum types that allow for the programmer to express more detailed invariants for it’s types. This is in spite of the fact that nothing is preventing the Haskell developer from writing their codebase <a href="https://hackage.haskell.org/package/acme-stringly-typed-1.0.0.0/docs/Acme-StringlyTyped.html">entirely using the <code>String</code> type</a> – which would hardly be enforcing any invariants at all. After all, a tweet from Donald Trump, the source code to the Linux kernel, the world’s nuclear launch codes, or the entire works of Shakespere translated to Polish all fit inside Haskell’s <code>String</code> type. So even the second meaning of “strongly typed” has a few different senses depending on exactly what we are talking about (i.e. a language, or a particular code-base).</p>
<p>I think that because this distinction between the meanings 1 and 2 of strongly/weakly typed are often conflated, languages which allow for implicit conversions in any capacity are automatically assumed to be more “weakly typed” in the second sense by association. This, together with the cognitive bias developers might have from working in a language with badly implemented implicit conversions, can lead to an overly quick dismissal of implicit conversions outright.</p>
<p>I don’t think it is always the case that implicit conversions are harmful, or that implicit conversions necessarily lead to a lack of “strength” in the second sense above. To clarify the situation, I’d like to be <em>explicit</em> about what I mean by implicit conversions, and classify systems of implicit conversions into two cases:</p>
<ol type="1">
<li>Arbitrary implicit conversions. From any type, to any type, at the language designer’s (or user’s – if the langauge lets users create their own implicit conversions) whim.</li>
<li>Principled implicit conversions. Only conversions from a “subtype” to a “supertype” is allowed.</li>
</ol>
<p>Case 1 here is what left a lot of developers with a bad taste in their mouth. For instance, <code>C++</code> lets you implicitly convert a <code>float</code> to an <code>int</code> – and JavaScript is like the wild west when it comes to implicit conversions. But what does the alternative look like?</p>
<p>As a first approximation, let’s interpret “subtype” as “subset”. Intuitively, <code>int32</code> is a <em>subset</em> of the type of <code>float</code>. Of course this isn’t strictly speaking true – the memory layout of these types is different, so one is not strictly speaking a “subset” of the other in that sense. What we really mean in this context is that there is a mapping (function) from <code>int32</code> to <code>float</code> that <em>behaves</em> like a “subset function”. In set theory, these are known as <em>injective functions</em>. More generally, in category theory, these are called <em>monomorphisms</em>, but we’ll get to that more later.</p>
<p>In other words: A function <span class="math inline"><em>f</em> : <em>X</em> → <em>Y</em></span> is injective if it maps distinct elements in <code>X</code> to distinct elements in <code>Y</code>. This can be viewed as kind of generalization of a “subset”, because such a function identifies <code>X</code> with the subset of elements of <code>Y</code> that <code>f</code> maps to (it’s “image”).</p>
<p>Ok, great! So, this would allow for an implicit conversion from <code>int32</code> to <code>float</code>, because we can define an injection from <code>int32</code> to <code>float</code> – but the opposite conversion would not be allowed, because <code>float</code> has more elements than <code>int</code>, so it is impossible to build an injection going the other way.</p>
<p>This also has problems. Consider an example like this (which those against any form of implicit conversion on primitive types will often cite):</p>
<pre><code>val x: Double = 7/2
&gt; 3.0 // (Expected 3.5)</code></pre>
<p>Or, perhaps even worse:</p>
<pre><code>val x: Double = 1/2*1.1
&gt; 0.0 // (Expected 0.55)
</code></pre>
<p>The issue is, this only causes an issue due to user expectations as to what “<code>/</code>” means. Now, I’m not saying that’s not a problem – but implicit conversions themselves are not to blame here, and this problem can be solved in other ways.</p>
<p>Before we get to that, I should note that I am not flat out against operator overloading, or other types of overloading in a language. That’s not the issue here either per se. Having <a href="https://en.wikipedia.org/wiki/ML_(programming_language)">two different sets of arithmetic operators</a> depending on whether you are working with ints or floats is not my cup of tea. The issue is <em>this particular case</em> of operator overloading – and in the next section, I hope to attempt to develop a general rule for why this particular case bothers me.</p>
<p>Consider how Haskell handles this. The type of the standard division operator in Haskell (<code>/</code>) is:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="ot">(/) ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>For those not familiar with Haskell, the <code>Fractional a</code> is a <em>typeclass constraint</em> on the type variable <code>a</code> – and essentially says “This function only works on <code>Fractional</code> types (for instance, <code>Float</code> or <code>Double</code> in Haskell)”. Whereas another function entirely is provided for integral division:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="fu">div</span><span class="ot"> ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>Arguably, it makes sense to keep these two different functions apart in a way that it doesn’t make sense to do for other kinds of operators because integral division is a fundamentally different beast than fractional division. But to explain precisely why that is, we need to dive into some theory.</p>
<h2 id="a-little-bit-of-algebra">A little bit of algebra</h2>
<p>I’ve touched a little bit <a href="https://sintrastes.github.io/blog/posts/2021-07-19-sum_types_are_not_a_silver_bullet.html">before</a> on my blog on the topic of abstract algebra, to help understand the analogy between classical algebra and <em>algebraic data types</em>. To summarize: Abstract algebra is the study of <em>algebraic structures</em>, which consist of a base set <code>X</code>, a set of operations on that set (such as <code>+</code>, <code>-</code>, <code>*</code>), and a set of laws that those operations have to obey.</p>
<p>In abstract algebra, a central notion is that of a <em>homomorphism</em>, or <em>structure-preserving-map</em> between two algebraic structures. To demonstrate what I mean by that, I’ll first introduce one of the simplest algebraic structures out there: A <em>monoid</em>.</p>
<p>A monoid is a just an interface on a type that provides a straightforward way of combining things. Namely:</p>
<ol type="1">
<li>A monoid consists of a binary operator <span class="math inline"> ⋅  : (<em>A</em>,<em>A</em>) → <em>A</em></span> that is associative. That is, for all <span class="math inline"><em>x</em>, <em>y</em>, <em>z</em> : <em>A</em></span> we have <span class="math inline">(<em>x</em>⋅<em>y</em>) ⋅ <em>z</em> = <em>x</em> ⋅ (<em>y</em>⋅<em>z</em>)</span>. What this means is that we can list a set of things being “combined” unambiguously as: <span class="math inline"><em>x</em> ⋅ <em>y</em> ⋅ <em>z</em> ⋅ <em>w</em> ⋅ ...</span>.</li>
<li>Furthermore, there is an element, called <span class="math inline"><em>i</em><em>d</em><em>e</em><em>n</em><em>t</em><em>i</em><em>t</em><em>y</em></span> such that <span class="math inline"><em>i</em><em>d</em><em>e</em><em>n</em><em>t</em><em>i</em><em>t</em><em>y</em></span> combined with anything is itself. i.e. <span class="math inline"><em>x</em> ⋅ <em>i</em><em>d</em><em>e</em><em>n</em><em>t</em><em>i</em><em>t</em><em>y</em> = <em>x</em></span> and <span class="math inline"><em>i</em><em>d</em><em>e</em><em>n</em><em>t</em><em>i</em><em>t</em><em>y</em> ⋅ <em>x</em> = <em>x</em></span></li>
</ol>
<p>If you’re familiar with the <a href="https://en.wikipedia.org/wiki/Composite_pattern">Composite</a> design pattern – this is an example of a monoid<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. For instance, in rxJava2:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">interface</span> Monoid&lt;<span class="dt">A</span>&gt; {</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>    <span class="kw">val</span> <span class="va">identity</span>: A</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>    <span class="kw">fun</span> <span class="fu">combine</span>(<span class="va">x</span>: <span class="dt">A</span>, <span class="va">y</span>: <span class="dt">A</span>): <span class="dt">A</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>}</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a><span class="kw">object</span> <span class="fu">DisposableMonoid</span>: <span class="dt">Monoid</span>&lt;<span class="dt">Disposable</span>&gt; {</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>    <span class="kw">override</span> <span class="kw">val</span> <span class="va">identity</span> = CompositeDisposable()</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>    <span class="kw">override</span> <span class="kw">fun</span> <span class="fu">combine</span>(<span class="va">x</span>: <span class="dt">Disposable</span>, <span class="va">y</span>: <span class="dt">Disposable</span>): <span class="dt">Disposable</span> {</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a>        <span class="kw">return</span> CompositeDisposable(x, y)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a>    }</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a>}</span></code></pre></div>
<p>Another example that will be fimiliar to software developers is lists! Consider (as an example of the laws):</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>listOf() + listOf(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>) == listOf(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>) == listOf(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>) + listOf()</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>(listOf(<span class="dv">1</span>,<span class="dv">2</span>) + listOf(<span class="dv">3</span>)) + listOf(<span class="dv">4</span>,<span class="dv">5</span>) == listOf(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>) == listOf(<span class="dv">1</span>,<span class="dv">2</span>) + (listOf(<span class="dv">3</span>) + listOf(<span class="dv">4</span>,<span class="dv">5</span>))</span></code></pre></div>
<p>For some more mathematical examples, note that real numbers under addition are a monoid with identity <code>0</code>, and they are also a monoid under multiplication with identity <code>1</code>.</p>
<p>Finally, for a arithmetical counter-example, note that divsion over the real numbers is in fact <em>not</em> a monoid. It fails the associativity condition – for instance: <code>(1.0/2.0)/2.0 == 0.25</code>, but <code>1.0/(2.0/2.0) == 1.0</code>. We will see later that this does in fact fit into another common algebraic structure – just not a monoid.</p>
<p>So what does it mean to have a function that preserves the structure of a monoid? Well, if we have two monoids <span class="math inline"><em>X</em></span> and <span class="math inline"><em>Y</em></span>, and a map <span class="math inline"><em>f</em> : <em>X</em> → <em>Y</em></span> between them, it means:</p>
<ol type="1">
<li><span class="math inline"><em>f</em></span> must map the identity of <span class="math inline"><em>X</em></span> to the identity of <span class="math inline"><em>Y</em></span>.</li>
<li><span class="math inline"><em>f</em>(<em>x</em> ⋅<sub><em>X</em></sub> <em>y</em>)</span> must equal <span class="math inline"><em>f</em>(<em>x</em>) ⋅<sub><em>Y</em></sub> <em>f</em>(<em>y</em>)</span> for all <span class="math inline"><em>x</em>, <em>y</em></span>, where <span class="math inline">⋅<sub><em>X</em></sub></span> is the “combine” operation of <span class="math inline"><em>X</em></span>, and <span class="math inline">⋅<sub><em>Y</em></sub></span> is the “combine” operation of <span class="math inline"><em>Y</em></span>.</li>
</ol>
<p>For other algebraic structures, the definition of a homomorphism is similar (special elements must map to special elements, and functions applied to the arguments of operators must yield the same result whether they are applied “under” or “over” the operations).</p>
<p>For an easy example of a monoid homomorphism, consider our example before of the reals under addition and the reals under multiplication. Note that, by high-school arithmetic:</p>
<p><span class="math display"><em>e</em><sup><em>x</em> + <em>y</em></sup> = <em>e</em><sup><em>x</em></sup> * <em>e</em><sup><em>y</em></sup></span></p>
<p>So the map <span class="math inline"><em>f</em>(<em>x</em>) = <em>e</em><sup><em>x</em></sup></span> transforms one monoid operation (addition) to another (multiplication). Neat! For identities, note that we also have:</p>
<p><span class="math display"><em>e</em><sup>0</sup> = 1</span></p>
<p>So the additive identity is sent to the multiplicative identity. We in fact have a monoid homomorphism from <span class="math inline">ℝ → ℝ</span>.</p>
<p>The astute reader might further notice that the natural logarithm (in fact, any logarithm) does the same thing, but in reverse:</p>
<pre><code>ln(x * y) = ln (x + y)
ln(1) = 0</code></pre>
<p>As a side-note: This actually provides some intuition for why decibels are measured on a logarithmic scale: We have something that physically multiplicative (decibels), that we want to measure additively (because our brains can comprehend that better!) – so we map the multaplicative scale to a lograithmic scale using a homomorphism!</p>
<p>Homomorphisms are powerful – as they preserve the structure of the algebra in question, they let us transfer results about one algebraic structure to another.</p>
<h2 id="rings-and-fields">Rings and Fields</h2>
<p>We noticed before that both the multiplicative and additive operations on the real numbers formed monoids. Together two such monoids form another algebraic structure called a <em>Ring</em>. I won’t get into all the laws, but I’ll define the structure itself using a Kotlin interface:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="kw">interface</span> Ring&lt;<span class="dt">A</span>&gt; {</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>    <span class="kw">val</span> <span class="va">addId</span>: A</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>    <span class="kw">val</span> <span class="va">mulId</span>: A</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>    <span class="kw">fun</span> <span class="fu">add</span>(<span class="va">x</span>: <span class="dt">A</span>, <span class="va">y</span>: <span class="dt">A</span>): <span class="dt">A</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>    <span class="kw">fun</span> <span class="fu">mul</span>(<span class="va">x</span>: <span class="dt">A</span>, <span class="va">y</span>: <span class="dt">A</span>): <span class="dt">A</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>    <span class="kw">fun</span> <span class="fu">negate</span>(<span class="va">x</span>: <span class="dt">A</span>): <span class="dt">A</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a>}</span></code></pre></div>
<p>Rings are meant to be a generalization of the algebraic strucutre of the integers – so any laws you can remember from primary school regarding the integers should hold for rings as well – but for those curious, <a href="https://en.wikipedia.org/wiki/Ring_(mathematics)#Definition">here</a> is the formal definition.</p>
<p>Notably absent from the structure of a ring is an operation for division! Since rings are meant to be generalizations of the integers, this makes sense. Integers do have a “division” operator, but it takes <em>integers</em> to <em>rational numbers</em>, not <em>integers</em> to <em>integers</em>.</p>
<p>Or, rather, I should say there there is no “proper” division operation on the integers, in the sense that there is no division operation on the integers that makes them into a <em>field</em>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="kw">interface</span> Field&lt;<span class="dt">A</span>&gt;: <span class="dt">Ring</span>&lt;<span class="dt">A</span>&gt; {</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>    <span class="kw">fun</span> <span class="fu">divide</span>(<span class="va">x</span>: <span class="dt">A</span>, <span class="va">y</span>: <span class="dt">A</span>): <span class="dt">A</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>}</span></code></pre></div>
<p>Here, in the field laws, <code>divide</code> has to satisfy the property that for all <em>non-zero</em> <code>x</code>: <code>mul(x, div(1,x)) == 1</code>. In other words, as one would say in abstract algebra<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>, <code>divide</code> is the <code>inverse</code> of <code>mul</code>.</p>
<p>Intuitively, it is easy to convince yourself (though perhaps not formally prove, without knowing some basic ring/field theory) that it is impossible for the integers to have such a <code>divide</code> operation. For instance, <code>2</code> does not have a multiplicative inverse, because that would have to be <code>1/2</code> (multiplicative inverses are unique when they exist) – which is not an integer.</p>
<p>So already, perhaps you can see why it may not be wise to identify the integral division <code>div</code> in your language, with the floating point (or “real”) division <code>/</code>. But let’s use our knowledge to make this a formal criterion:</p>
<h2 id="some-criteria-for-sane-implicit-conversions">Some criteria for “sane” implicit conversions</h2>
<p>Let’s pretend for a moment that <code>/ : (Int, Int) -&gt; Int</code> was in fact a valid division operation, in the sense of field theory. This is maybe not too much of a stretch. Integer division is “kind of” an inverse. For instance, <code>(x * y) / y = x</code> always works<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>.</p>
<p>Now, rather than considering all injective functions valid choices for implicit conversions, let’s instead look at only allowing <em>injective homomorphisms</em>.</p>
<p>Let’s then consider the explicit mapping <span class="math inline"><em>t</em><em>o</em><em>D</em><em>o</em><em>u</em><em>b</em><em>l</em><em>e</em> : <em>I</em><em>n</em><em>t</em> → <em>D</em><em>o</em><em>u</em><em>b</em><em>l</em><em>e</em></span>. Is it a homomorphism with respect to the integral and floating point division operations?</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a> <span class="fl">1.</span>toDouble()/<span class="fl">2.</span>toDouble</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>    = <span class="fl">1.0</span>/<span class="fl">2.0</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>    = <span class="fl">0.5</span></span></code></pre></div>
<p>whereas:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a>(<span class="dv">1</span>/<span class="dv">2</span>).toDouble()</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>   = <span class="fl">0.</span>toDouble()</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>   = <span class="fl">0.0</span></span></code></pre></div>
<p>So that is a resounding no!</p>
<p>This led me to come up with the following “soundness” criterion for implicit conversions:</p>
<p>A system of implicit conversions is “sane” if:</p>
<ol type="1">
<li>All implicit conversions are injective as functions on terms of the programming language.</li>
<li>There are no cycles in the graph of implicit conversions (conversions only ever go one direction!)</li>
<li>If there is a structure common to both types X and Y, the implicit conversion should respect that strucutre (i.e. be a homomorphism).</li>
<li>All implicit conversions from a type <code>X</code> to a type <code>Y</code> should be in some sense <em>unique</em>, or <em>cannoncial</em> at least.</li>
</ol>
<p>Since this whole problem deals with the messy, psychological aspect of subverting human expectations, this is not a formal soundness criterion – but merely a guideline to for developing “sane” implicit conversions that will not subvert developer expectations. Each three of these criteria, I think, could also be taken and debated seperately.</p>
<p>Is it really nescesary that all implicit conversions are injective as functions? I can’t really think of a use case of this where I would want this at the moment (assuming it is still “sound” in the sense that this conversion is a homomorphism for the relevant strucutures – I <em>know</em> that I don’t want the standard lossy C/C++-style implicit conversion from <code>Float</code> to <code>Int</code>) – but that doesn’t mean that non-injective implicit conversions are nescesarialy problematic.</p>
<p>Is it really nescesary to prohibit cycles in the graph of implicit conversions? Again, just because <code>int &lt;-&gt; float</code> implicit conversions are bad doesn’t nescesarialy mean that bidirectional conversions are bad per se. In Haskell, where there are several different encodings of <em>strings</em> (string, strict and lazy bytestrings, strict and lazy text, bytestring builders, etc…), where these representations are essentailly isomorphic – I think it would be very useful to have some implicit conversions. It certainly would save me some time from asking myself “…How do I convert from X to Y again?”. However, in a langauge with strong, Hindley-Milner-esque type inference, allowing these sorts of implicit conversions could potentially be an implementation concern.</p>
<p>Of all of these, I honestly think that <code>3</code> and <code>4</code> are the strongest, but of course, I’d be happy to have a debate or more examples/counterexamples of problematic behavior for any of these four points. I think this is an area that deserves further explanation.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>In order for this to work, strictly speaking, we may need to slightly modify the notion of “equality” of composite disposables.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>Monoids with an inverse form another important algebraic structure called a group, which is incredibly useful for describing symmetries.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>I’m a little bit rusty since my grad school math days, but I should note here that this remark can in fact be made more formal. There is a <a href="https://en.wikipedia.org/wiki/Euclidean_domain">spectrum</a> of different algebraic structures between rings and fields, going from less to more capability to preform “divisions”, as well as other useful properties. <a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
			<script src="https://utteranc.es/client.js"
		      repo="Sintrastes/sintrastes.github.io"
              issue-term="title"
              theme="boxy-light"
              crossorigin="anonymous"
            async>
        </script>
        </section>
    </article>
    <div id="wrapper">
  </div>
</div>

        <div id="copyright" class="container">
	    <p>&copy; Nathan Bedell 2021. All exposition is free to use under the <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en">CC BY-NC-SA 3.0</a> license. All relevant code snippets are licensed under the <a href="https://sintrastes.github.io/blog/license.html">MIT license</a>. | Css template adapted from: <a href="http://templated.co">TEMPLATED</a>. | Generated with <a href="https://jaspervdj.be/hakyll/">hakyll</a> | Icons made by <a href="https://www.freepik.com" title="Freepik">Freepik</a> from <a href="https://www.flaticon.com/" title="Flaticon">www.flaticon.com</a></p>
	    <p>
	        <a href="https://github.com/sintrastes/">
	          <img height="32" src="http://sintrastes.github.io/blog/images/github-logo.png"/> 
	        </a>
	         &nbsp &nbsp
	        <a href="https://www.linkedin.com/in/nathan-bedell-a1b740189/">
	          <img height="32" src="http://sintrastes.github.io/blog/images/linkedin.png"/>
	        </a>
	    </p>
        </div>
    </body>
</html>
]]></description>
    <pubDate>Fri, 17 Dec 2021 00:00:00 UT</pubDate>
    <guid>http://sintrastes.github.io/blog/posts/2021-12-17-being_explicit_about_implicit_conversions.html</guid>
    <dc:creator>Nathan Bedell</dc:creator>
</item>
<item>
    <title>Sum types are not a silver bullet: Why you shouldn't always reach for that sealed class.</title>
    <link>http://sintrastes.github.io/blog/posts/2021-07-19-sum_types_are_not_a_silver_bullet.html</link>
    <description><![CDATA[<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Interchange - Sum types are not a silver bullet: Why you shouldn't always reach for that sealed class.</title>
        <link rel="stylesheet" href="/css/light-theme.css" />
        <link rel="stylesheet" href="/css/light-syntax.css" />
        <link rel="stylesheet" href="/css/slider.css" />
        <link href="https://sintrastes.github.io/blog/atom.xml" type="application/atom+xml" rel="alternate" title="Sitewide Atom feed" />
        <link href="https://sintrastes.github.io/blog/rss.xml" type="application/rss+xml" rel="alternate" title="Sitewide Rss feed" />

        <script>
            function toggleTheme() {
                // Obtains an array of all <link> elements.
                // Select your element using indexing.
                var theme = document.getElementsByTagName('link')[0];
                var syntaxTheme = document.getElementsByTagName('link')[1];
      
                // Change the value of href attribute 
                // to change the css sheet.
                if (theme.getAttribute('href').includes('light-theme.css')) {
                    theme.setAttribute('href', 'https://sintrastes.github.io/blog/css/dark-theme.css');
                    syntaxTheme.setAttribute('href', 'https://sintrastes.github.io/blog/css/dark-syntax.css');
                } else {
                    theme.setAttribute('href', 'https://sintrastes.github.io/blog/css/light-theme.css');
                    syntaxTheme.setAttribute('href', 'https://sintrastes.github.io/blog/css/light-syntax.css');
                }
            }
            
            
        </script>
    </head>
    <body> 
        <div id="header-wrapper">
	<div id="header">
		<div id="blog-title">
          <div horizontal layout>
            <a href="#">
              <h2>Interchange</h2>
            </a>
            <div id="subheading">
              <h3> : A blog about category theory, logic, and programming.</h3>
            </div>
          </div>
		</div>
		<div id="menu">
		  <ul>
		    <li><a href="https://sintrastes.github.io/" accesskey="1" title="">Homepage</a></li>
			<li class="active"><a href="#" accesskey="4" title="">Blog</a></li>
			<li>
			  <label class="switch">
			    <img height="16" src="http://sintrastes.github.io/blog/images/contrast.png"></img>
			    <div>
				  <input type="checkbox" onclick="toggleTheme()"/>
              	  <span class="slider round"></span>
                </div>
		      </label>
			</li>
		  </ul>
		</div>
	</div>	
</div>
<div id="wrapper">
  <div>
    <article>
        <section class="header">
          <div class="title">
            <h2>Sum types are not a silver bullet: Why you shouldn't always reach for that sealed class.</h2>
            <p>
              Posted on July 19, 2021
              
                by Nathan Bedell
              
            </p>
          </div>
        </section>
        <section class="container" id="body">
            <p>In Kotlin, the notion of a <em>sealed class</em> (or, more recently, in Kotlin 1.5, that of a <em>sealed interface</em>) is a mechanism for limiting the inheritance of a class (or interface) to one of a fixed number of cases. Together with <em>data classes</em>, this can be used to emulate what is known in the functional programming community as <em>algebraic data types</em>, often abbreviated ADT (much to the chagrin of those who might also abbreviate <em>abstract data type</em> as ADT). These algebraic data types are the combination of <em>product types</em>, and <em>sum types</em> (which correspond to Kotlin’s sealed classes).</p>
<p>In recent years, this feature has found its way into more and more traditional OOP and imperative languages: Rust, Swift, Kotlin – heck, even Java 15 – all have a form of these “algebraic data types”, and so the comments of this blog post will apply to any of those languages, as well as to more traditional functional languages supporting algebraic data types such as Haskell, ML, OCaml, F#, and Scala.</p>
<p>In this post I’ll argue that in both cases these algebraic data types have the potential to be overused, and give an example of an anti-pattern that can arise with an over-eager use of sum types that I’ve decided to call “The product of sums trap”. I’ve definitely fallen into this trap myself, so I wanted to share some advice on when using sum types might be a mistake. But first, I’d like to cover a bit of background into the mathematics of algebraic data types. If you already are familiar with algebraic data types and their mathematical underpinning, or if you’d simply prefer to get into the meat of the post and some practical examples, you might want to start from <a href="#why-are-adts-good">here</a></p>
<h2 id="aside-putting-the-algebraic-into-adts">Aside: Putting the “Algebraic” into ADTs:</h2>
<p>Why are they called <em>algebraic</em> data types? Well, the notion (like many notions in the typed FP community) comes from <em>category theory</em>, which <a href="https://www.youtube.com/watch?v=BF6kHD1DAeU">Steve Awodey</a> sometimes likes to describe as the <em>abstract algebra of functions</em>. Now, before you run off, I should say: You do not need to understand category theory to understand this post. I simply introduce the idea below briefly for some context in understanding what I mean by “product of sums” in my analogy.</p>
<p>For those not familiar, whereas primary school algebra focuses on <em>computations</em> and <em>algorithms</em> in a particular algebraic system, abstract algebra is the study of <em>algebraic structures</em> themselves, and the sets of rules that define them. For instance, even back in primary school, you probably learned the rules:</p>
<div class="mathblock">
<ol type="1">
<li>For all real numbers x, y, and z: <span class="math inline">(<em>x</em>+<em>y</em>) + <em>z</em> = <em>x</em> + (<em>y</em>+<em>z</em>)</span></li>
<li>For all real numbers x and y: <span class="math inline"><em>x</em> × <em>y</em> = <em>y</em> × <em>x</em></span></li>
</ol>
</div>
<p>I won’t list them all here, but the ones you learned are technically called the <em>field laws</em> of the real numbers, stating that the real numbers satisfy all the properties of the algebraic structure known as a “field”.</p>
<p>To add some more detail to Awodey’s characterization of category theory, I’d like to say further that whereas <em>abstract algebra</em> is the study of <em>algebraic operations</em> (such as <code>+, *, -</code>) and <em>equations</em>, category theory is the study of <em>operations on types</em> (in category theory we would say <em>objects</em>) and <em>functions</em> (more specifically, <em>isomorphisms</em>).</p>
<p>An isomorphism <span class="math inline"><em>f</em> : <em>X</em> → <em>Y</em></span> (restricting myself here to to case of types and functions) is simply a function that has an inverse – that is, a function <span class="math inline"><em>g</em> : <em>Y</em> → <em>X</em></span> such that:</p>
<div class="mathblock">
<ol type="1">
<li>For all x of type X: <span class="math inline"><em>g</em>(<em>f</em>(<em>x</em>)) = <em>x</em></span></li>
<li>For all x of type Y: <span class="math inline"><em>f</em>(<em>g</em>(<em>x</em>)) = <em>x</em></span></li>
</ol>
</div>
<p>We say that two types are “isomorphic” and write: <span class="math inline"><em>X</em> ≡ <em>Y</em></span> if there exists an isomorphism between them. I think a good intuition for this is that two types being isomorphic means that they are “essentially the same”, or “two different presentations of the same data”. Given this, I can finally explain why algebraic data types are – algebraic.</p>
<p>One way of thinking about algebraic data types is that they can be implemented in terms of two “type operators” – <span class="math inline">+</span> and <span class="math inline">×</span>. These type operators then obey very similar laws to the ones we are familiar with from elementary arithmetic, but where equality is replaced with isomorphism:</p>
<div class="mathblock">
<ol type="1">
<li>For all types X, Y, and Z: <span class="math inline">(<em>X</em>+<em>Y</em>) + <em>Z</em> ≡ <em>X</em> + (<em>Y</em>+<em>Z</em>)</span></li>
<li>For all types X and Y: <span class="math inline"><em>X</em> × <em>Y</em> ≡ <em>Y</em> × <em>X</em></span></li>
</ol>
</div>
<p>We can define these types in Kotlin as follows:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">data</span> <span class="kw">class</span> Product&lt;<span class="dt">A</span>,<span class="dt">B</span>&gt;(<span class="kw">val</span> <span class="va">first</span>: <span class="dt">A</span>, <span class="kw">val</span> <span class="va">second</span>: <span class="dt">B</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="kw">sealed</span> <span class="kw">class</span> Sum&lt;<span class="dt">A</span>,<span class="dt">B</span>&gt; {</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>  <span class="kw">data</span> <span class="kw">class</span> InL&lt;<span class="dt">A</span>,<span class="dt">B</span>&gt;(<span class="kw">val</span> <span class="va">value</span>: <span class="dt">A</span>): <span class="dt">Sum</span>&lt;<span class="dt">A</span>,<span class="dt">B</span>&gt;()</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>  <span class="kw">data</span> <span class="kw">class</span> InR&lt;<span class="dt">A</span>,<span class="dt">B</span>&gt;(<span class="kw">val</span> <span class="va">value</span>: <span class="dt">B</span>): <span class="dt">Sum</span>&lt;<span class="dt">A</span>,<span class="dt">B</span>&gt;()</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>}</span></code></pre></div>
<p>You may recognize the <code>Product</code> type as being essentially the same as Kotlin’s <code>Pair&lt;A,B&gt;</code> – and if you did, you’re already getting the hang of the concept of an <em>isomorphism</em>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">fun</span> <span class="fu">productToPair</span>(<span class="va">product</span>: <span class="dt">Product</span>&lt;<span class="va">A</span>,<span class="va">B</span>&gt;): <span class="dt">Pair</span>&lt;<span class="dt">A</span>,<span class="dt">B</span>&gt; {</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>    <span class="kw">return</span> Pair(product.first, product.second)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>}</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a><span class="kw">fun</span> <span class="fu">pairToProduct</span>(<span class="va">pair</span>: <span class="dt">Pair</span>&lt;<span class="va">A</span>,<span class="va">B</span>&gt;): <span class="dt">Product</span>&lt;<span class="dt">A</span>,<span class="dt">B</span>&gt; {</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>    <span class="kw">return</span> Product(pair.first, pair.second)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>}</span></code></pre></div>
<p>You may also recognize the <code>Sum&lt;A,B&gt;</code> I’ve defined here as being isomorphic to the <code>Either&lt;A,B&gt;</code> type defined in <a href="https://arrow-kt.io/docs/0.10/apidocs/arrow-core-data/arrow.core/-either/">arrow</a>.</p>
<h2 id="why-are-adts-good">Why are ADTs good?</h2>
<p>Before getting into the problems that can arise for maintainability when making use of sum types, I’d like first to provide a positive example of how sum types can be good.</p>
<p>If you’ve taken a course in algorithms and data structures, and haven’t been lucky enough to work in a language with sum types, you’ve probably written code like this before:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">open</span> <span class="kw">class</span> BinaryTree&lt;<span class="dt">A</span>&gt; {</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>    <span class="kw">val</span> <span class="va">node</span>: A</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>    <span class="kw">val</span> <span class="va">left</span>: BinaryTree&lt;A&gt;?</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>    <span class="kw">val</span> <span class="va">right</span> BinaryTree&lt;A&gt;?</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>}</span></code></pre></div>
<p>This works pretty well. This is a binary tree with a value of type <code>A</code> at each point of the tree, where each tree can have possibly a left sub-tree, and possibly a right sub-tree.</p>
<p>What if we wanted to model a binary tree where values are only stored in the leaves? We might try making use of inheritance to encode the two separate cases then:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">open</span> <span class="kw">class</span> BinaryTree&lt;<span class="dt">A</span>&gt;</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a><span class="kw">class</span> Branch&lt;<span class="dt">A</span>&gt;(</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>  <span class="kw">val</span> <span class="va">left</span>: <span class="dt">BinaryTree</span>&lt;<span class="va">A</span>&gt;?</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>  <span class="kw">val</span> <span class="va">right</span>: <span class="dt">BinaryTree</span>&lt;<span class="va">A</span>&gt;?</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>): <span class="dt">BinaryTree</span>&lt;<span class="dt">A</span>&gt;()</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a><span class="kw">class</span> Leaf&lt;<span class="dt">A</span>&gt;(<span class="kw">val</span> <span class="va">node</span>: <span class="dt">A</span>): <span class="dt">BinaryTree</span>&lt;<span class="dt">A</span>&gt;()</span></code></pre></div>
<p>I use the <code>open</code> keyword here to enable inheritance, but this sort of thing would be possible by default in Java or C++.</p>
<p>Consider what would happen if we wanted to write a function on such a tree. I’ll write an incredibly simple (non-recursive) one for illustration purposes:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="co">/** Print some diagnostic information about a binary tree*/</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="kw">fun</span> <span class="fu">peek</span>(<span class="va">tree</span>: <span class="dt">BinaryTree</span>&lt;<span class="va">Int</span>&gt;): <span class="dt">String</span> =</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>    <span class="cf">when</span>(tree) {</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>        <span class="kw">is</span> Branch -&gt; {</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>            <span class="st">&quot;This is a branch.&quot;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>        }</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>        <span class="kw">is</span> Leaf -&gt; {</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>            <span class="st">&quot;This is a leaf with value ${tree.node}.&quot;</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a>        }</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a>        -- We have to put <span class="kw">this</span> here, or the compiler yells at us.</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a>        <span class="cf">else</span> -&gt; <span class="kw">throw</span> IllegalStateException(<span class="st">&quot;UNREACHABLE&quot;</span>)</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a>    }</span></code></pre></div>
<p>That is annoying. The compiler can’t deduce that there are exactly two cases here to consider – and rightly so, there is nothing preventing someone in a third-party code base using our code as a library, or future maintainers from additionally sub-classing <code>BinaryTree</code>, so Kotlin forces us to explicitly account for that in our code.</p>
<p>This is where the sealed modifier comes in. If we replace <code>open class BinaryTree&lt;A&gt;</code> with <code>sealed class BinaryTree&lt;A&gt;</code>, Kotlin only allows inheritance from the base <code>BinaryTree</code> class in the same file it is defined. The compiler (and we!) can now rest assured that there are exactly two types of <code>BinaryTree</code>: A <code>Branch</code>, and a <code>Leaf</code>, and we can safely omit the <code>else</code> branch in the above function.</p>
<p>So, sealed classes are good at making definitions of data types, with strong compiler guarantees that say “This data type will be in exactly one of a finite number of forms”.</p>
<p>Beyond better communicating our intent to the compiler and later maintainers of our code-base, sealed classes are also useful for making illegal states un-representable.</p>
<p>What do I mean by this? Oftentimes, functions will accept a larger set of inputs than is actually considered “valid”, and upon accepting “invalid” input, will:</p>
<ul>
<li>Throw an exception</li>
<li>Have undefined/unexpected behavior.</li>
<li>Return null/some kind of result type.</li>
</ul>
<p>This is, in some sense, unavoidable in any program that deals with the “outside world”. For instance, any sort of parsing function is of this form (only <em>valid</em> strings will be successfully parsed). However, the best thing to do, both to avoid having to parse more than is necessary (which could cause performance issues), and to make life easier as a programmer (dealing directly with a <code>MyObject</code> is a lot easier than remembering that a particular <code>String</code> is (probably) a serialized representation of a <code>MyObject</code>), is to only parse things at the <em>edges</em> of your application, and then to pass around more structured data types internally.</p>
<p>The issue (which is still sometimes unavoidable) is for “internal” functions in the code base which accept a larger set of inputs than is considered “valid”. For example, consider the following function:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="co">/** </span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="co"> * Takes a field of type A, B, or C, and</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a><span class="co"> * updates the view accordingly.</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a><span class="co"> *</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a><span class="co"> * Warning: Throws an IllegalArgumentException unless</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a><span class="co"> *  exactly one of the arguments is non-null. View can</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a><span class="co"> *  only have one of the three fields set at a time.</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a><span class="co"> */</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a><span class="kw">fun</span> <span class="fu">setField</span>(<span class="va">fieldA</span>: <span class="dt">A?</span>, <span class="va">fieldB</span>: <span class="dt">B?</span>, <span class="va">fieldC</span>: <span class="dt">C?</span>)</span></code></pre></div>
<p>With sealed classes, we can create a data type that exactly models the constraint “exactly one of the arguments is non-null”, so we can re-write this function to not have to deal with exceptions!</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="kw">sealed</span> <span class="kw">class</span> SomeField {</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>    <span class="kw">data</span> <span class="kw">class</span> First(<span class="kw">val</span> <span class="va">fieldA</span>: <span class="dt">A</span>): <span class="dt">SomeField</span>()</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>    <span class="kw">data</span> <span class="kw">class</span> Second(<span class="kw">val</span> <span class="va">fieldB</span>: <span class="dt">B</span>): <span class="dt">SomeField</span>()</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>    <span class="kw">data</span> <span class="kw">class</span> Third(<span class="kw">val</span> <span class="va">fieldC</span>: <span class="dt">C</span>): <span class="dt">SomeField</span>()</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>}</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a>/** </span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a> * <span class="dt">Takes</span> <span class="dt">a</span> <span class="dt">field</span> <span class="dt">of</span> <span class="dt">type</span> <span class="dt">A</span>, <span class="dt">B</span>, <span class="dt">or</span> <span class="dt">C</span>, <span class="dt">and</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a> * <span class="dt">updates</span> <span class="dt">the</span> <span class="dt">view</span> <span class="dt">accordingly</span>.</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a> */</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a><span class="kw">fun</span> <span class="fu">setField</span>(<span class="va">field</span>: <span class="dt">SomeField</span>)</span></code></pre></div>
<p>Now we no longer have to deal with the possibility that someone called <code>setField</code> with the wrong arguments.</p>
<h2 id="case-study-extensible-repl">Case study: Extensible REPL</h2>
<p>Lets say you want to build a REPL for a programming language, like <code>ghci</code>, or the <code>python</code> executable. Usually these applications, in addition to allowing you to make new definitions and evaluate expressions, allow you to enter specific “commands”. For instance, in <code>ghci</code>, <code>:set +m</code> lets you unable multi-line entry mode.</p>
<p>At first, if you’re new to sealed classes/ADTs, and you’re generally trying to design your systems such that you <a href="https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/">parse, don’t validate</a>, it might seem like a good idea to define an algebraic data type for commands in this repl, where each term of the sum corresponds to one possible command, such as the following:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="kw">sealed</span> <span class="kw">class</span> ReplCommand {</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>    <span class="co">/** Turn mutli-line mode on or off. */</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>    <span class="kw">data</span> <span class="kw">class</span> SetMultiLine(<span class="kw">val</span> <span class="va">value</span>: <span class="dt">Boolean</span>): <span class="dt">ReplCommand</span>()</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>    /** <span class="dt">List</span> <span class="dt">the</span> <span class="dt">most</span> <span class="dt">recent</span> <span class="dt">definitions</span> <span class="dt">that</span> <span class="dt">have</span> <span class="dt">been</span> <span class="dt">added</span> <span class="dt">into</span> <span class="dt">the</span> <span class="dt">REPL</span>. */</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>    <span class="kw">object</span> ListDefinitions: <span class="dt">ReplCommand</span>()</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>}</span></code></pre></div>
<p>We could then define a function for parsing such commands from raw strings:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="kw">fun</span> <span class="fu">parseReplCommand</span>(<span class="va">input</span>: <span class="dt">String</span>): <span class="dt">ReplCommand?</span> =</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>    <span class="co">// Commands start with a &#39;:&#39; character, so look for that first.</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>    <span class="cf">if</span> (input.firstOrNull() == <span class="ch">&#39;:&#39;</span>) {</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>        <span class="kw">val</span> <span class="va">cmdText</span> = input.split(<span class="st">&quot; &quot;</span>).first()</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>        <span class="cf">when</span>(cmdText) {</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>            <span class="st">&quot;set_m&quot;</span> -&gt; {</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>                <span class="kw">val</span> <span class="va">rawArg</span> = input.substringAfter(<span class="ch">&#39; &#39;</span>)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a>                rawArg.readAsBooleanOrNull?.let { parsed -&gt;</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a>                    ReplCommand.SetMultiline(parsed)</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a>                }</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true"></a>            }</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true"></a>            <span class="st">&quot;list_defs&quot;</span> -&gt; {</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true"></a>                ReplCommand.ListDefinitions</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true"></a>            }</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true"></a>        }</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true"></a>    } <span class="cf">else</span> {</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true"></a>        <span class="kw">null</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true"></a>    }</span></code></pre></div>
<p>A little verbose – if we plan to add many more commands in the future, it might be worth looking into using a parsing library, or at least building up some utilities to make argument parsing a bit easier, but so far nothing too troubling.</p>
<p>Let’s then say we have a <code>ReplCtx</code> that defines a context of actions we can preform in our Repl <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="kw">interface</span> ReplCtx {</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>    <span class="kw">fun</span> <span class="fu">setMultilineMode</span>(<span class="va">value</span>: <span class="dt">Boolean</span>)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>    <span class="kw">fun</span> <span class="fu">getDefinitions</span>(): <span class="dt">List</span>&lt;<span class="dt">MyLanguageDeclaration</span>&gt;</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>    <span class="kw">fun</span> <span class="fu">addDefinition</span>(<span class="va">defn</span>: <span class="dt">MyLanguageDeclaration</span>): <span class="dt">Boolean</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a>    <span class="kw">fun</span> <span class="fu">display</span>(<span class="va">text</span>: <span class="dt">String</span>)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a>    <span class="kw">fun</span> <span class="fu">prompt</span>(): <span class="dt">String?</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a>}</span></code></pre></div>
<p>Given this, we can define a function which takes a <code>ReplCommand</code>, and preforms an action in a <code>ReplCtx</code>. This cleanly separates our parsing code from our action-oriented code.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="kw">fun</span> <span class="fu">ReplCtx</span>.<span class="fu">executeCommand</span>(<span class="va">command</span>: <span class="dt">ReplCommand</span>) {</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>    <span class="cf">when</span>(command) {</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>        <span class="kw">is</span> ReplCommand.SetMultiline -&gt; {</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>           <span class="co">// Set the multiline mode to whatever the user&#39;s selection is.</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>           <span class="kw">val</span> <span class="va">userSelection</span> = command.value</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a>           setMulitlineMode(userSelection)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a>        }</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a>        <span class="kw">is</span> ReplCommand.ListDefinitions -&gt; {</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true"></a>            <span class="co">// Get the current list of definitions.</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true"></a>            <span class="kw">val</span> <span class="va">defns</span> = getDefinitions()</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true"></a>            <span class="co">// Display the last 10 definitions to the prompt.</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true"></a>            display(</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true"></a>                defns.take(<span class="dv">10</span>)</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true"></a>            )</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true"></a>        }</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true"></a>    }</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true"></a>}</span></code></pre></div>
<p>Consider for a moment the organization of the code-base so far. We have multiple functions (a <em>product</em>)<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>, each of which handles a number of different cases (a <em>sum</em>). This is what is meant by the <em>product of sums</em> trap.</p>
<p>To explore why this can be problematic, let’s see what happens if we add a new command to <code>ReplCommand</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="co">/** List all of the definitions that have been added into the REPL. */</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a><span class="kw">object</span> ListAllDefinitions: <span class="dt">ReplCommand</span>()</span></code></pre></div>
<p>The compiler will happily tell us that we need to add a new case to <code>executeCommand</code>. Great! This is why sealed classes are helpful.</p>
<p>Unfortunately, this helpfulness only goes so far. Notice, for example, every time we add a new <code>ReplCommand,</code> the compiler will <em>not</em> complain that we forgot to add a case to <code>parseReplCommand</code>. If you didn’t document that <code>ReplCommand</code>s are parsed by using the <code>parseReplCommand</code> function – and you’re either coming back to this code-base after some time away, and have forgotten the structure, or completely new to the code-base, you might scratch your head for awhile, studying the code until you finally see that a new case needs to be added to <code>parseReplCommand</code>.</p>
<p>Iterate on this design a few times, add a few new features and a couple of new commands, and you’ve created, what <a href="https://github.com/Sintrastes/bli-prolog/blob/a87a7f8fb4d1736db1357aee93910f269b16ef5b/src/Bli/App/Config.hs">I’ve discovered myself</a> to be a big bowl of spaghetti.</p>
<p>Now when you want to add a new command, you’ve got <em>several</em> places in the code-base you have to modify, all of which may or may not make the compiler warn you if you’ve missed one of them. You’re keeping up with that documentation for all of this, right?</p>
<p>Worst comes to worst, let’s say that after dealing with this code-base for awhile, you decide you want users to be able to implement their own custom commands, perhaps through a custom DSL, or some sort of plugin system<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>. Now we can’t even use sealed types at all! <em>Extensible at run-time</em> is kind of antithetical to <em>known to have exactly these cases at compile-time</em>.</p>
<p>This led me to come up with the following maxim for myself:</p>
<div class="blockquote">
<p>Organize your codebase as if you had to support a system that lets you add new cases at run-time.</p>
</div>
<p>This works, because organizing your code-base this way makes life easier not just for you in the future if you indeed decide to implement such a feature, but for <em>any</em> developer that has to add a new case to your system. Let’s consider what this alternative looks like:</p>
<h2 id="the-extensible-solution">The extensible solution</h2>
<p>Rather than defining a case for each command in our system, let’s consider what a command <em>needs</em> in other to function like a command<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="kw">interface</span> ReplCommand&lt;<span class="dt">A</span>&gt; {</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>    <span class="co">/** String used to identify the command. */</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>    <span class="kw">val</span> <span class="va">name</span>: <span class="kw">String</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>    <span class="co">/** Function to parse the arguments of the command. */</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a>    <span class="kw">fun</span> <span class="fu">parseArgs</span>(<span class="va">input</span>: <span class="dt">String</span>): <span class="dt">A?</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a>    /** <span class="fu">Function</span> <span class="fu">to</span> <span class="fu">run</span> <span class="fu">once</span> <span class="fu">the</span> <span class="fu">arguments</span> <span class="fu">have</span> <span class="fu">been</span> <span class="fu">parsed</span> <span class="fu">correctly</span>. */</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a>    <span class="kw">fun</span> <span class="fu">ReplCtx</span>.<span class="fu">action</span>(<span class="va">args</span>: <span class="dt">A</span>)</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a>}</span></code></pre></div>
<p>Surprise! The solution in an OOP language is to simply use a plain old interface! In a language like Haskell or C without interfaces, you’d just use typed records/structs. For instance, in Haskell<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> the solution would look something like:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">ReplCommand</span> a <span class="ot">=</span> <span class="dt">ReplCommand</span> {</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a><span class="ot">    name ::</span> <span class="dt">String</span>,</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a><span class="ot">    parseArgs ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a,</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a><span class="ot">    action  ::</span> a <span class="ot">-&gt;</span> <span class="dt">Repl</span> ()</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a>}</span></code></pre></div>
<p>For a lot of us, sum types are shiny and new – so, especially when first learning about them, we may be biased towards trying to incorporate them into every solution – but sometimes the “boring” solution is the right one.</p>
<p>Let’s see what our solution looks like now with this interface instead of a sum type. Our code for handling commands looks like:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="kw">fun</span> <span class="fu">parseReplCommand</span>(<span class="va">command</span>: <span class="dt">ReplCommand</span>&lt;<span class="va">A</span>&gt;, <span class="va">input</span>: <span class="dt">String</span>): <span class="dt">A?</span> {</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>    <span class="co">// Commands start with a &#39;:&#39; character, so look for that first.</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>    <span class="cf">if</span> (input.firstOrNull() == <span class="ch">&#39;:&#39;</span>) {</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a>        <span class="kw">val</span> <span class="va">cmdText</span> = input.split(<span class="st">&quot; &quot;</span>).first()</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a>        <span class="co">// If the name of the command is the same as thing one,</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true"></a>        <span class="co">// try parsing the arguments to the command.</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true"></a>        <span class="cf">if</span> (command.name == cmdText) {</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true"></a>            <span class="kw">val</span> <span class="va">argsText</span> = input.substringAfter(<span class="ch">&#39; &#39;</span>)</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true"></a>            command.parseArgs(argsText)</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true"></a>        } <span class="cf">else</span> {</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true"></a>            <span class="kw">null</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true"></a>        }</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true"></a>    } <span class="cf">else</span> {</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true"></a>        <span class="kw">null</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true"></a>    }</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true"></a>}</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true"></a></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true"></a><span class="co">/** Pair of a command and the arguments to that command of the correct type. */</span></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true"></a><span class="kw">data</span> <span class="kw">class</span> CommandWithArgs&lt;<span class="dt">A</span>&gt;(<span class="kw">val</span> <span class="va">command</span>: <span class="dt">ReplCommand</span>&lt;<span class="va">A</span>&gt;, <span class="kw">val</span> <span class="va">args</span>: <span class="dt">A</span>) {</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true"></a>    <span class="kw">fun</span> <span class="fu">ReplCtx</span>.<span class="fu">runAction</span>() {</span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true"></a>        command.action(args)</span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true"></a>    }</span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true"></a>}</span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true"></a></span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true"></a><span class="kw">fun</span> <span class="fu">ReplCtx</span>.<span class="fu">startRepl</span>(<span class="va">commands</span>: <span class="dt">List</span>&lt;<span class="va">ReplCommand</span>&lt;*&gt;) {</span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true"></a>    <span class="cf">while</span>(<span class="kw">true</span>) {</span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true"></a>        <span class="co">// Prompt the user for input (continue on empty input)</span></span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true"></a>        <span class="kw">val</span> <span class="va">input</span> = prompt() ?: <span class="cf">continue</span></span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true"></a>        <span class="co">// Try parsing each of the commands in order, and return a bundle of</span></span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true"></a>        <span class="co">// the first arguments to successfully be parsed, and the corresponding argument:</span></span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true"></a>        <span class="kw">val</span> <span class="va">parsedCommand</span> = commands.map { cmd -&gt;</span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true"></a>            parseReplCommand(cmd, input)?.let {</span>
<span id="cb15-33"><a href="#cb15-33" aria-hidden="true"></a>                CommandWithArgs(cmd, it)</span>
<span id="cb15-34"><a href="#cb15-34" aria-hidden="true"></a>            }</span>
<span id="cb15-35"><a href="#cb15-35" aria-hidden="true"></a>        }</span>
<span id="cb15-36"><a href="#cb15-36" aria-hidden="true"></a>            .filterNotNull()</span>
<span id="cb15-37"><a href="#cb15-37" aria-hidden="true"></a>            .firstOrNull()</span>
<span id="cb15-38"><a href="#cb15-38" aria-hidden="true"></a>        <span class="cf">if</span> (parsedCommand != <span class="kw">null</span>) {</span>
<span id="cb15-39"><a href="#cb15-39" aria-hidden="true"></a>            parsedCommand.runAction()</span>
<span id="cb15-40"><a href="#cb15-40" aria-hidden="true"></a>        } <span class="cf">else</span> {</span>
<span id="cb15-41"><a href="#cb15-41" aria-hidden="true"></a>            display(<span class="st">&quot;Error parsing command.&quot;</span>)</span>
<span id="cb15-42"><a href="#cb15-42" aria-hidden="true"></a>        }</span>
<span id="cb15-43"><a href="#cb15-43" aria-hidden="true"></a>    }</span>
<span id="cb15-44"><a href="#cb15-44" aria-hidden="true"></a>}</span></code></pre></div>
<p>Where now we can define our commands themselves as:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="kw">object</span> SetMultiLine: <span class="dt">ReplCommand</span>&lt;<span class="dt">Boolean</span>&gt; {</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a>    <span class="kw">override</span> <span class="kw">val</span> <span class="va">name</span> = <span class="st">&quot;set_m&quot;</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>    <span class="kw">override</span> <span class="kw">fun</span> <span class="fu">parseArgs</span>(<span class="va">input</span>: <span class="dt">String</span>): <span class="dt">Boolean?</span> {</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a>        <span class="kw">return</span> <span class="cf">when</span>(input) {</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a>            <span class="st">&quot;on&quot;</span>  -&gt; <span class="kw">true</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a>            <span class="st">&quot;off&quot;</span> -&gt; <span class="kw">false</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true"></a>            <span class="cf">else</span>  -&gt; <span class="kw">null</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true"></a>        }</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true"></a>    }</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true"></a>    <span class="kw">override</span> <span class="kw">fun</span> <span class="fu">ReplCtx</span>.<span class="fu">action</span>(<span class="va">args</span>: <span class="dt">Boolean</span>) {</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true"></a>        setMulitlineMode(args)</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true"></a>    }</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true"></a>}</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true"></a></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true"></a><span class="kw">object</span> ListDefinitions: <span class="dt">ReplCommand</span>&lt;<span class="dt">Unit</span>&gt; {</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true"></a>    <span class="kw">override</span> <span class="kw">val</span> <span class="va">name</span> = <span class="st">&quot;list_defs&quot;</span></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true"></a>    <span class="kw">override</span> <span class="kw">fun</span> <span class="fu">parseArgs</span>(<span class="va">input</span>: <span class="dt">String</span>): <span class="dt">Unit?</span> {</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true"></a>        <span class="kw">return</span> <span class="cf">when</span>(input) {</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true"></a>            <span class="st">&quot;&quot;</span>   -&gt; <span class="kw">Unit</span></span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true"></a>            <span class="cf">else</span> -&gt; <span class="kw">null</span></span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true"></a>        }</span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true"></a>    }</span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true"></a>    <span class="kw">override</span> <span class="kw">fun</span> <span class="fu">ReplCtx</span>.<span class="fu">action</span>(<span class="va">args</span>: <span class="dt">Unit</span>) {</span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true"></a>    	<span class="co">// Get the current list of definitions.</span></span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true"></a>        <span class="kw">val</span> <span class="va">defns</span> = getDefinitions()</span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true"></a>        <span class="co">// Display the last 10 definitions to the prompt.</span></span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true"></a>        defns.take(<span class="dv">10</span>).forEach {</span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true"></a>            display(it.toString())</span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true"></a>        }</span>
<span id="cb16-30"><a href="#cb16-30" aria-hidden="true"></a>    }</span>
<span id="cb16-31"><a href="#cb16-31" aria-hidden="true"></a>}</span></code></pre></div>
<p>While this is still a bit verbose, and for more complicated commands with multiple arguments, we may again want to consider use of a specialized parsing DSL for parsing command arguments, we have accomplished our stated goal: The implementation of <code>ReplCommands</code> is cleanly separated from the logic of running our REPL.</p>
<h2 id="some-final-notes">Some final notes</h2>
<p>While in this post, I have attempted to come up with a criterion for when it is appropriate to use sum types, and when it is appropriate to simply use records, I suspect the answer will not be entirely satisfactory to everyone. The naive maxim I proposed earlier in this post is, I fear, a bit strong, and requires some clarification.</p>
<p>“Organize your codebase as if you had to support a system that lets you add new cases at run-time.” is I think a great suggestion for things that could be classified as “features” of an application. Repl commands are a good example of this – they’re something tangible you can talk about in a program, of which the number of “features” included is more-or-less arbitrary. For some other examples I think fit this definition well, consider:</p>
<ul>
<li>“Editor actions” one could preform in an IDE, which can be bound to various keybindings.</li>
<li>Menus or configuration windows in a GUI application.</li>
</ul>
<p>Whereas things that are “good fits” for sum types include:</p>
<ul>
<li>Abstract syntax trees for a programming, domain-specific, or markup language.</li>
<li>Specific data types (e.x. trees, or result types), where making such types “extensible” doesn’t really make much sense (A binary tree with additional cases is no longer a binary tree!)</li>
</ul>
<p>However, even in the case of ADTs, people often think about making them as extensible as possible. What I’ve covered today concerns the aspect of extensibility regarding <em>extension by new cases</em>, but more generally, a lot of people have spent a lot of time thinking about the <a href="https://en.wikipedia.org/wiki/Expression_problem">expression problem</a>, which concerns the problem of designing data types so that it is easy to both <em>add new cases</em>, and to <em>add new operations</em> on that data.</p>
<p>Moreover, even in the case of things that one might consider to be “features”, there are a few considerations which might lead one to use sum types to model them.</p>
<p>For instance, an important consideration when deciding whether or not to use sum types is the fact that writing things in a generic enough way to be extensible is oftentimes more challenging than writing out each of the cases manually with a sum type. Just in our example above, we can see that in order to support commands with varying argument types, we had to use Kotlin’s type projections, and a utility class <code>CommandWithArgs</code> to get everything to typecheck<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>. If you’re just in the prototyping stage, that might be more effort than it’s worth. Then again, it may pay off in the future to spend the time getting a solid, extensible design down from the beginning. I think it’s partially a matter of personal preference and how you want to work.</p>
<p>I think that a general rule of thumb here is:</p>
<div class="blockquote">
<p>If there are a small number of cases to consider, and it is not likely that more cases will be added in the future, consider modeling your data as a sum type.</p>
</div>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>We will not worry about the actual implementation of such a class here – but I quite like this style of programming in Kotlin. It is reminiscent of <a href="https://hackage.haskell.org/package/mtl">MTL</a>-style programming in Haskell<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>Multiple functions defined in a module can be considered to be a product of those functions, as given such a module, we have access to <em>both</em> functions. This observation can be made more formal in languages with first-class modules like <a href="https://ocaml.org/manual/firstclassmodules.html">OCaml</a>.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>On the JVM you’d use a class loader for this. Languages targeting native binaries like Haskell will need some form of <a href="https://hackage.haskell.org/package/plugins">dynamic linking</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>The analogy might be a bit strained at this point, but it seems to me like this alternative way of thinking might be thought of as a “sum of products” solution. I attempted to try to work this out formally as an isomorphism between the two solutions, but was not able to say anything concrete (at least for this example). Perhaps there is a more advanced analysis that could be done here to say something more meaningful!<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>Note that where one would use a function with receiver parameter in Kotlin, one often uses a custom monad of some kind in Haskell, which is what <code>Repl</code> is here.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>I may write a post in the future on this, and related techniques in Kotlin.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
			<script src="https://utteranc.es/client.js"
		      repo="Sintrastes/sintrastes.github.io"
              issue-term="title"
              theme="boxy-light"
              crossorigin="anonymous"
            async>
        </script>
        </section>
    </article>
    <div id="wrapper">
  </div>
</div>

        <div id="copyright" class="container">
	    <p>&copy; Nathan Bedell 2021. All exposition is free to use under the <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en">CC BY-NC-SA 3.0</a> license. All relevant code snippets are licensed under the <a href="https://sintrastes.github.io/blog/license.html">MIT license</a>. | Css template adapted from: <a href="http://templated.co">TEMPLATED</a>. | Generated with <a href="https://jaspervdj.be/hakyll/">hakyll</a> | Icons made by <a href="https://www.freepik.com" title="Freepik">Freepik</a> from <a href="https://www.flaticon.com/" title="Flaticon">www.flaticon.com</a></p>
	    <p>
	        <a href="https://github.com/sintrastes/">
	          <img height="32" src="http://sintrastes.github.io/blog/images/github-logo.png"/> 
	        </a>
	         &nbsp &nbsp
	        <a href="https://www.linkedin.com/in/nathan-bedell-a1b740189/">
	          <img height="32" src="http://sintrastes.github.io/blog/images/linkedin.png"/>
	        </a>
	    </p>
        </div>
    </body>
</html>
]]></description>
    <pubDate>Mon, 19 Jul 2021 00:00:00 UT</pubDate>
    <guid>http://sintrastes.github.io/blog/posts/2021-07-19-sum_types_are_not_a_silver_bullet.html</guid>
    <dc:creator>Nathan Bedell</dc:creator>
</item>

    </channel>
</rss>
